import {Component} from 'react';
import PropTypes from 'prop-types';
import assignDeep from 'assign-deep';
import {injectStylePrefixed} from 'styletron-utils';

const testMode = (process.env.NODE_ENV === 'TEST'),
      emptyThemeProvider = {theme: {meta: {globalMeta: {}}}};

export default class Styled extends Component {

  // we pull context from above
  static contextTypes = {

    // from StyletronProvider (see styletron-react)
    styletron: PropTypes.object,

    // from ThemeProvider
    themeProvider: PropTypes.shape({
      theme:            PropTypes.object.isRequired,
      installComponent: PropTypes.func.isRequired,
      applyMiddleware:  PropTypes.func.isRequired
    })
  };

  /*
   every styled component can take several props which allow you to override
   the styles generated by the component directly:

   * className => if the user of a component passes a className prop explicitly,
     it is prepended to the list of styletron classes. use this to link to legacy or
     hard-coded classes in an external CSS file (e.g., "margined" or "select-multi")

   * style => the user can pass in a styletron object to override specific styles.
     this overloads React's "style" prop. it integrates with the styletron system,
     so the result of passing a style prop will actually be additional classes,
     not an inline style attribute

   * localTheme => allows the user to override the entire theme object for a component.
     this includes the component's meta, as well as its base styles (the meta cannot
     be overridden using the "style" prop). the local theme is for this component only,
     not the entire subtree
  */

  static propTypes = {
    // basic props
    themeName:    PropTypes.string,   // unnamed components are not themeable; useful for one-offs
    staticStyle:  PropTypes.object,
    dynamicStyle: PropTypes.func,

    // for per-instance styling
    className:    PropTypes.string,
    style:        PropTypes.object,
    localTheme:   PropTypes.object,

    // we only accept a render callback function for children
    children:     PropTypes.func.isRequired
  }

  constructor(props, context) {
    super(props, context);

    if (!context.themeProvider && !testMode)
      console.error('Styled components must be rendered inside a ThemeProvider.');  // eslint-disable-line

    if (!context.styletron && !testMode)
      console.error('Styled components must be rendered inside a StyletronProvider.');  // eslint-disable-line

    this.componentName = props.themeName;

    // ensure that the component's static style is inserted into the master theme.
    // unnamed components are not installed into the theme; see getComponentTheme() below
    //
    if (this.componentName && context.themeProvider)
      context.themeProvider.installComponent(this.componentName, props.staticStyle || {});
  }

  getRootTheme() {
    if (this.componentName && this.context.themeProvider)
      return this.context.themeProvider.theme[this.componentName];
    return this.props.staticStyle;   // for unthemed (unnamed) components
  }

  getComponentTheme() {
    let theme = this.getRootTheme();
    if (this.props.localTheme)
      theme = assignDeep({}, theme, this.props.localTheme);
    return theme || {};
  }

  // this is where the magic happens. here we figure out what styles need to be applied
  // to this instance of the component. returns an object of styletron attributes (not classes)
  //
  getStyle() {
    let {themeProvider = emptyThemeProvider} = this.context,
        componentTheme = this.getComponentTheme(),
        styleObj;

    // use the component's dynamic styling function to adjust the styles for this instance
    // based on props
    //
    if (typeof this.props.dynamicStyle === 'function') {
      styleObj = this.props.dynamicStyle({

        // the base theme for this component
        componentTheme,

        // the global meta (for colors and other global attributes)
        globalMeta: themeProvider.theme.meta,

        // last, but not least, the props
        props: this.props
      });
    }
    else
      styleObj = componentTheme;

    // all components accept a "style" prop for custom styletron attributes.
    // this overrides React's use of "style", as described above.
    //
    if (this.props.style)
      styleObj = assignDeep({}, styleObj, this.props.style);

    return styleObj;
  }

  // passed to the user to render sub-components. pass in any styletron object, and
  // we'll convert it to classes for you
  //
  classify = styletronObject => {
    try {
      return injectStylePrefixed(
        this.context.styletron,
        this.context.themeProvider.applyMiddleware(styletronObject)
      );
    }
    catch(e) {
      return '';
    }
  }

  render() {
    const styleProperties = this.getStyle(),
          {className, children, themeName, staticStyle, dynamicStyle, localTheme, style, ...passThroughProps} = this.props,    // eslint-disable-line
          {themeProvider = emptyThemeProvider} = this.context,

          // convert the style properties into a set of classes. this is where
          // we let styletron do its magic
          styletronClasses = this.classify(styleProperties),

          paramBlock = {
            // the base theme of your component
            componentTheme: this.getComponentTheme(),

            // the global meta (for colors, etc)
            globalMeta: themeProvider.theme.meta,

            // easy access to "classify", for building classes for sub-components
            classify: this.classify
          };

    // invoke the render callback with three params
    return children(

      // PARAM 1: className
      // (see above for comments on the use of the className prop for legacy CSS classes)
      (className ? className + ' ' : '') + styletronClasses,

      // PARAM 2: pass through props
      passThroughProps,

      // PARAM 3: everything else, wrapped up into an object
      paramBlock
    );
  }
}
