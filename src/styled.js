import React, {Component} from 'react';
import PropTypes from 'prop-types';
import assignDeep from 'assign-deep';
import {asConsumer} from './consumer';


@asConsumer
class Styled extends Component {

  /*
   every styled component can take several props which allow you to override
   the styles generated by the component directly:

   * className => if the user of a component passes a className prop explicitly,
     it is prepended to the list of styletron classes. use this to link to legacy or
     hard-coded classes in an external CSS file (e.g., "margined" or "select-multi")

   * style => the user can pass in a styletron object to override specific styles.
     this overloads React's "style" prop. it integrates with the styletron system,
     so the result of passing a style prop will actually be additional classes,
     not an inline style attribute

   * localTheme => allows the user to override the entire theme object for a component.
     this includes the component's meta, as well as its base styles (the meta cannot
     be overridden using the "style" prop). the local theme is for this component only,
     not the entire subtree
  */

  static propTypes = {
    // basic props
    themeName:    PropTypes.string,   // unnamed components are not themeable; useful for one-offs
    staticStyle:  PropTypes.object,
    dynamicStyle: PropTypes.func,

    // for per-instance styling
    className:    PropTypes.string,
    style:        PropTypes.object,
    localTheme:   PropTypes.object,

    // from context wrappers
    themeContext: PropTypes.object,
    styletron:    PropTypes.object,

    // we only accept a render callback function for children
    children:     PropTypes.func.isRequired
  }

  state = {ready: false}

  constructor(props) {
    super(props);
    const componentName = this.componentName = props.themeName;

    if (componentName
      && props.themeContext
      && props.themeContext.installComponent
      && !props.themeContext.isReady(componentName))
    {
      this.props.themeContext.installComponent(componentName, props.staticStyle || {})
        .then(() => {
          this.setState({ready: true});
        });
    }
    else {
      this.state = {ready: true};
    }
  }

  getRootTheme() {
    let theme = null;
    if (this.componentName && this.props.themeContext)
      theme = this.props.themeContext.theme[this.componentName];
    return theme || this.props.staticStyle;   // for unthemed (unnamed) components
  }

  getComponentTheme() {
    let theme = this.getRootTheme();
    if (this.props.localTheme)
      theme = assignDeep({}, theme, this.props.localTheme);
    return theme || {};
  }

  // this is where the magic happens. here we figure out what styles need to be applied
  // to this instance of the component. returns an object of styletron attributes (not classes)
  //
  getStyle() {
    let themeContext = this.props.themeContext,
        componentTheme = this.getComponentTheme(),
        styleObj;

    // use the component's dynamic styling function to adjust the styles for this instance
    // based on props
    //
    if (typeof this.props.dynamicStyle === 'function' && this.state.ready && themeContext) {
      styleObj = this.props.dynamicStyle({

        // the base theme for this component
        componentTheme,

        // the global meta (for colors and other global attributes)
        globalMeta: themeContext.theme.meta,

        // last, but not least, the props
        props: this.props
      });
    }
    else
      styleObj = componentTheme;

    // all components accept a "style" prop for custom styletron attributes.
    // this overrides React's use of "style", as described above.
    //
    if (this.props.style)
      styleObj = assignDeep({}, styleObj, this.props.style);

    return styleObj;
  }

  // passed to the user to render sub-components. pass in any styletron object, and
  // we'll convert it to classes for you
  //
  classify = styletronObject => {

    if (!this.state.ready)
      return '';

    try {
      return this.props.styletron.renderStyle(
        this.props.themeContext.applyMiddleware(styletronObject)
      );
    }
    catch(e) {
      return '';
    }
  }

  render() {
    if (!this.state.ready)
      return null;

    const styleProperties = this.getStyle(),
          {className, children, themeContext, styletron, themeName, staticStyle, dynamicStyle, localTheme, style,    // eslint-disable-line
            ...passThroughProps} = this.props,

          // convert the style properties into a set of classes. this is where
          // we let styletron do its magic
          styletronClasses = this.classify(styleProperties),

          paramBlock = {
            // the base theme of your component
            componentTheme: this.getComponentTheme(),

            // the global meta (for colors, etc)
            globalMeta: themeContext.theme.meta,

            // easy access to "classify", for building classes for sub-components
            classify: this.classify
          };

    // invoke the render callback with three params
    return children(

      // PARAM 1: className
      // (see above for comments on the use of the className prop for legacy CSS classes)
      (className ? className + ' ' : '') + styletronClasses,

      // PARAM 2: pass through props
      passThroughProps,

      // PARAM 3: everything else, wrapped up into an object
      paramBlock
    );
  }
}

export default Styled;
